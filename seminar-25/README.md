# Семинар №25
## Шифрование. Шифрование с использованием OpenSSL/LibreSSL

---

### Введение

**Криптографическая хэш-функция** — это отображение последовательности битов в последовательность битов, обладающие 
следующими свойствами:
 * должно быть крайне сложно получить исходные данные, имея хэш;
 * зная хэш и его изначальное значение, должно крайне трудно восстановить другое сообщение, имеющее такой же хэш;
 * высокая стойкость к коллизиям.

Криптографическую хэш-функцию можно воспринимать как параметризованную хэш-функцию, где параметр — это **ключ** 
шифрования, условно 128-битное слово, которое есть у отправляющей и принимающей сторон.

Но все не так просто:

```bash
echo "user=user1 password_hash=$(echo -n 123456 | openssl sha256 -r)"
echo "user=user2 password_hash=$(echo -n qwerty | openssl sha256 -r)"
echo "user=admin password_hash=$(echo -n 123456 | openssl sha256 -r)"
```
Получим:
```bash
user=user1 password_hash=8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
user=user2 password_hash=65e84be33532fb784c48129675f9eff3a682b27168c0ea744b2cf58ee02337c5
user=admin password_hash=8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92
```
Вывод:
> Получили коллизию c которой нужно бороться.  
> Более того, если использовать один и тот же ключ многократно, то вероятность подбора и взлома шифрования 
> увеличивается.

Поэтому отправленные данные надо "подсаливать". **Соль** — это последовательность битов, которую передают открыто по 
незащищенному каналу, и применяют совместно с криптографической хэш-функцией (конкатенировать с plain text, 
побитовый xor c plain text, ...).

```bash
echo "user=user1 salt=saltAHFG password_hash=$(echo -n saltAHFG%3.1415-2.718182 | openssl sha256 -r)"
echo "user=user2 salt=saltMSIG password_hash=$(echo -n saltMSIG%sfkjvdjkth | openssl sha256 -r)"
echo "user=admin salt=saltPQNY password_hash=$(echo -n saltPQNY%3.1415-2.718182 | openssl sha256 -r)"
```
Получим:
```bash
user=user1 salt=saltAHFG password_hash=0c9ce37e04e94dc13f16304a93b21e7f2c44ca32d6c26fbea3375ea85263aaa0
user=user2 salt=saltMSIG password_hash=df9c27cc066b36be6dc73a39f03e73ec4996b378bfff562421e53bf85f3a99c5
user=admin salt=saltPQNY password_hash=8af9bf88fbe91b010c37d5065c90935c5bb51f5e2898bd92a7235581bd0ccb36
```

---

### Симметрическое шифрование

Позволяет шифровать большие объемы текста. Для шифрования и расшифровки используется общий секрет.
**Шифроблокноты** — это самый надежный из симметричных шифров: генерируется случайная последовательность большой длины 
и становится ключом.

Рассмотрим пример с [шифром Вернама](https://ru.wikipedia.org/wiki/Шифр_Вернама).

Понятно, что ключ можно не генерировать такого же размера, что и сами данные. Достаточно рассматривать данные 
поблочно и шифровать поблочно, сохраняя последовательность блоков зашифрованном сообщении.

Есть несколько подходов (режимов) к поблочному шифрованию:
 * `ECB (Electronic CodeBook)` — к каждому блоку применяем криптографическую хэш-функцию. **Плюсы:** легко 
   распараллеливать. **Минусы:** одинаковые блоки будут иметь тот же самый шифро-блок, что плохо (сохранение 
   статистических особенностей открытого текста).
![](./pics/ecb.png)
 * `CBC (Cipher Block Chaining)` — перед процедурой шифрования текущего блока сделаем XOR c предыдущим зашифрованным 
   блоком. В случае самого первого блока используем фиктивный блок — "вектор инициализации" — `IV`.  **Плюсы:** 
   одинаковые блоки  не будут иметь тот же самый шифро-блок. **Минусы:** нельзя распараллеливать.
 ![](./pics/cbc.png)
 * `CTR (Counter mode)` — перед процедурой шифрования применяем XOR с солью, значение которой зависит от номера блока. **Плюсы:**
   одинаковые блоки не будут иметь тот же самый шифро-блок, можно поблочно распараллеливать.
 * [и многие другие...](https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B6%D0%B8%D0%BC_%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

---

### Асимметрическое шифрование

В симметричном шифровании у отправителя и получателя должен быть общий секрет. А что делать если его нет? Использовать асимметричное шифрование!

Обычно применяется для обмена некоторой метаинформацией и получения общего секрета.

Известные алгоритмы:
 * RSA
 * Протокол Диффи-Хеллмана (дискретное логарифмирование, вспоминайте ОКТЧ)

---

### Основы шифрования в Linux

Криптография в Linux, как и во многих других UNIX-подобных системах реализована с помощью пакета `openssl` или совместимого с ним форка `libressl`.

Пакет предоставляет:
* команду `openssl` для выполнения операций в командной строке
* библиотеку `libcrypto` с реализацией алгоритмов шифрования
* библиотеку `libssl` с реализацией взаимодействия по протоколам SSL и TLS.

---

### Вычисление хеш-значений

Команды:
* `openssl md5`
* `openssl sha256`
* `openssl sha512`

Вычисляют хеш-значение для указанного файла и выводят его в читаемом виде на стандартный поток выввода. 
Дополнительная опция `-binary` указывает вывод в бинарном формате. Если имя файла не указано, то вычисляется хеш-значение для данных со стандартного потока ввода.

---

### Симметричное шифрование

Команда:

```
openssl enc -ШИФР -in ИМЯФАЙЛА -out ВЫХФАЙЛ
```

Выполняет шифрование *симметричным ключем*, то есть некоторым "паролем", который является одинаковым как для 
шифрования, так и для обратной операции дешифрования.

Полный список поддерживаемых шифров отображается командой `openssl enc -ciphers`. Наиболее часто используемые:

* `des` - достаточно старый алгоритм с использованием 56-битного ключа;
* `aes256` или `aes-256-cbc` - более надежный и достаточно быстрый;
* `base64` - без шифрования (ключ не требуется); удобный способ конвертировать бинарные файлы в текстовое представление и обратно.

Опция `-d` означает обратное преобразование, то есть *дешифрование*. Опция `-base64` подразумевает, что зашифрованные данные дополнительно преобразуются в кодировку Base64, например, для передачи данных в виде текста.

После запуска команды будет запрошен пароль и его подтверждение. В случае, когда нужно автоматизировать запуск команды, используется опция `-pass`, после которой передается, каким именно образом задается пароль:
* `pass:ПАРОЛЬ` - пароль задается обычным текстом в виде аргумента командной строки; жутко небезопасно;
* `env:ПЕРЕМЕННАЯ` - пароль задается определенной переменной окружения; немного лучше, но можно выяснить через `/proc/.../environ`;
* `file:ИМЯФАЙЛА` - пароль берется из файла;
* `fd:ЧИСЛО` - пароль берется из файлового дескриптора с указанным номером; используется при запуске через `fork`+`exec`.

Поскольку алгоритмы симметричного шифрования подразумевают использование ключа фиксированного размера, текстовый пароль произвольной длины предварительно преобразуется с помощью хеш-функции. По умолчанию используется SHA-256, но это можно задавать с помощью опции `-md АЛГОРИТМ`.

Помимо пароля, в ключ входит ещё одна составляющая - *соль* размером 8 байт, которая хранится в самом зашифрованном файле. Это значение генерируется случайным образом, но для возпроизводимости результата может быть явным образом задана с помощью опции `-S HEX`, где `HEX` - восьмибайтное значение в шестнадцатеричной записи.

---

### Шифрование с использованием пары ключей

Стандартным алгоритмом для шифрования с использованием пары ключей считается RSA.

Генерация ключей осуществляется командой:
```
openssl genrsa -out ФАЙЛ РАЗРЯДНОСТЬ
```

Если имя выходного файла не указано, то ключ в текстовом формате будет сохранен на стандартный поток вывода. Обычно  ключи RSA хранят в файлах с суффиксом имени `.pem`.

Разрядность определяет стойкость ключа, по умолчанию - 2048 бит.

Поскольку приватный ключ где-то должен храниться, причем безопасным методом, хорошей практикой считается его хранение в зашифрованном виде, для этого используется шифрование с симметричным ключем:
```
openssl genrsa -aes256 -passout ОПЦИИ_ПАРОЛЯ
```

При использовании зашифрованного закрытого ключа, необходимо будет каждый раз указывать пароль, заданный при его создании.

Извлечение публичного ключа из приватного осуществляется командой:
```
openssl rsa -in ПРИВАТНЫЙ_КЛЮЧ -out ПУБЛИЧНЫЙ_КЛЮЧ -pubout
```

Если при создании пары ключей использовалось шифрование, то необходимо ввести пароль, либо задать его через `-passin`.

Шифрование с использованием открытого ключа:
```
openssl rsautl -encrypt -pubin -inkey ПУБЛИЧНЫЙ_КЛЮЧ -in ФАЙЛ -out ВЫХОД
```

Обратная операция с использованием закрытого ключа:
```
openssl rsautl -decrypt -inkey ПРИВАТНЫЙ_КЛЮЧ -in ФАЙЛ -out ВЫХОД
```

Ограничением алгоритма RSA является то, что размер шифруемых данных не может превышать размер ключа. С этим можно бороться следующими способами:
1. Делить исходные данные на блоки размером по 2 или 4 Кбайт и шифровать их по-отдельности
2. Генерировать случаным образом одноразовый *сеансовый ключ*, который будет использован в паре с алгоритмом симметричного шифрования, но сам будет зашифрован с помощью RSA.

```
# Генерируем случайный ключ длиной 30 байт и сохраняем
# его текстовое Base64 представление в переменной $KEY
KEY=`openssl rand -base64 30`


# Шифруем симметричный ключ с помощью открытого ключа RSA
echo $KEY | openssl rsautl -encrypt -pubin \
                           -inkey public.pem \
                           -out symm_key_encrypted.bin

# Шифруем данные из большого файла README.md симметричным
# ключем из переменной $KEY, которая предварительно
# экспортируется, чтобы быть доступной дочернему процессу
export KEY
openssl enc -aes256 -in README.md \
                    -out README_encrypted.bin \
                    -pass env:KEY

# Забываем сеансовый ключ - он больше не нужен
unset KEY
```

Далее можно смело передавать по незащищенному каналу файлы `README_encrypted.bin`, который содержит данные, и `symm_key_encrypted.bin` с зашифрованным симметричным ключем.

Для расшифровки необходимо восстановить сеансовый симметричный ключ, и используя его - дешифровать данные:
```
# Расшифровываем сеансовый симметричный ключ с помощью
# приватного ключа RSA и сохраняем в переменной $KEY
KEY=`openssl rsautl -decrypt \
                    -inkey private.pem \
                    -in symm_key_encrypted.bin`

# Выполняем декодирование файла с данными, используя
# полученный сеансовый ключ
  export KEY
  openssl enc -d -aes256 -pass env:KEY \
              -in README_encrypted.bin

# Забываем расшифрованный сеансовый ключ
unset KEY
```

---

### API библиотеки `libcrypto`

В качестве онлайн-документации по API OpenSSL удобнее использовать документацию из проекта [LibreSSL](https://www.libressl.org).

---

### Использование с CMake

Если сторонний фреймворк состоит из нескольких библиотек, то команда `find_package` позволяет указать, какие именно необходимо использовать, указав их перечень после `COMPONENTS`:
```
find_package(OpenSSL COMPONENTS Crypto REQUIRED)
```

В случае успешного нахождения `libcrypto` из OpenSSL, будут определены переменные `${OPENSSL_INCLUDE_DIR}` и `${OPENSSL_CRYPTO_LIBRARY}`.

---

### Workflow

Преобразования данных криптографическими функциями подразумевает три стадии:
1. Инициализация - функции, заканчивающиеся на `Init`
2. Добавление очередной порции данных с помощью одной из функций, имя которой заканчивается на `Update`. Этот процесс можно повторять итеративно по мере поступления данных
3. Финализация - функции, оканчивающиеся на `Final`; на этом этапе появляется итоговый результат преобразования.

---

### Функции `libcrypto`

Функции, имена которых начинаются с `SHA` или `MD5` предназначены для вычисления хеш-значений. Они используют простой workflow из трех стадий.

Для кодирования или декодирования с использованием симметричного ключа используется стандартный workflow, но на стадии инициализации настраивается *контекст* - переменная, которая хранит состояние шифрующего автомата.

Пример:
```
// Создание контекста
EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();

// Генерация ключа и начального вектора из
// пароля произвольной длины и 8-байтной соли
EVP_BytesToKey(
  EVP_aes_256_cbc(),          // алгоритм шифрования
  EVP_sha256(),               // алгоритм хеширования пароля
  salt,                       // соль
  password, strlen(password), // пароль
  1,                          // количество итераций хеширования
  key,                        // результат: ключ нужной длины
  iv                          // результат: начальный вектор нужной длины
);

// Начальная стадия: инициализация
EVP_DecryptInit(
  ctx,                        // контекст для хранения состояния  
  EVP_aes_256_cbc(),          // алгоритм шифрования
  key,                        // ключ нужного размера
  iv                          // начальное значение нужного размера
);
```
