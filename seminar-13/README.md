# Семинар №13
## Запуск программ через fork-exec* & лимиты

---

### Системный вызов `exec`

Системный вызов `exec` предназначен для замены программы текущего процесса. Как правило, используется совместно с `fork`, но не обязательно.

Си-оболочки для системного вызова `exec` имеют несколько разных сигнатур.

```
int execve(const char *filename,
           char *const argv[],
           char *const envp[]);           
int execvpe(.....) // параметры аналогично execve

int execv(const char *filename, char *const argv[])
int execvp(......) // параметры аналогично execv

int execle(const char *filename,
           const char arg0, ..., /* NULL */,
           const char env0, ..., /* NULL */);

int execl(const char *filename,
          const char arg0, ..., /* NULL */);
int execlp(......) // параметры аналогично execl

```

Различные буквы в суффиксах названий `exec` означают?
* `v` или `l` - параметры передаются в виде массивов (`v`), заканчивающихся элементом `NULL`, либо в виде переменного количества аргументов (`l`), где признаком конца перечисления аргументов является значение `NULL`.
* `e` - кроме аргументов программы передаются переменные окружения в виде строк `КЛЮЧ=ЗНАЧЕНИЕ`.
* `p` - именем программы может быть не только имя файла, но и имя, которое нужно найти в одном из каталогов, перечисленных в переменной окружения `PATH`.

Возвращаемым значением `exec` может быть только значение `-1` (признак ошибки). В случае успеха, возвращаемое значение уже в принципе не имеет никакого смысла, поскольку будет выполняться другая программа.

Аргументы программы - это то, что передаётся в функцию `main` (на самом деле, они доступны из `_start`, поскольку располагаются на стеке). Первым аргументом (с индексом `0`), как правило, является имя программы, но это не является обязательным требованием.

Классическим способом запуска новой программы является пара системных вызовов:

```
if (0 == fork) {
  execlp(program, program, NULL);
  perror("exec"); exit(1);
}
```

Замена выполняемой программы с помощью `exec` оставляет неизменным многие аттрибуты процесса, например, открытые файловые дескрипторы, лимиты, и переменные окружения, установленные через `setenv`.

Таким образом, между вызовами `fork` и `exec` можно провести дополнительную настройку программы перед выполнением.

```
if (0 == fork) {
  // Заменить стандартные потоки ввода/вывода на файлы
  // (имитация операции >ВЫХОД <ВХОД в bash)
  close(0);
  close(1);
  /* 0 = */ open(in_file, O_RDONLY);
  /* 1 = */ open(out_file, O_WRONLY|O_CREAT|O_TRUNC, 0640);

  execlp(program, program, NULL);
  perror("exec"); exit(1);
}
```

Для того, чтобы случайно (в достаточно больших программах) не передать открытый файловый дескриптор новой программе, в системном вызове `open` предусмотрен флаг открытия `O_CLOEXEC`, который означает, что файл должен быть закрыт при вызове `exec`.

### Лимиты процессов

С процессом связаны некоторые лимиты (ограничения) на используемое процессорное время, максимальный объём памяти, количество файловых дескрипторов, процессов и т. д.

Лимиты подразделяются на *жёсткие*, которые обычные пользователи могут только уменьшать (хотя `root` может и увеличивать), и *мягкие*, которые де-факто являются значениями по умолчанию, и их можно увеличить до жёсткого лимита.

Примерами жёстких лимитов являются ограничения на количество процессов или объём доступной памяти. Пример мягкого лимита - это размер стека, который по умолчанию в Linux равен 8Мб, но может быть изменен произвольным образом, в том числе в большую сторону.

Мягкие (Soft) можно посмотреть `ulimit -S -a` и жесткие (Hard) `ulimit -H -a`.

Получение и установка лимитов осуществляются с помощью системных вызовов `getrlimit` и `setrlimit`.

Что можно ограничивать:

 * `RLIMIT_CPU` - лимит на процессорное время, которое доступно процессу
   * `ulimit -t 1` - запретить процессам тратить больще 1 секунды процессорного времени.
 * `RLIMIT_FSIZE` - лимит на увеличение размера файлов.
   * `ulimit -f 100000` - ограничить максимальный размер создаваемого файла в 100 MB
 * `RLIMIT_DATA` - лимит на размер сегмента данных (глобальные переменные + куча).
   * `ulimit -d 48000` - ограничить максимальный размер сегмента данных в 48 MB
 * `RLIMIT_STACK` - лимит на размер стека ~ просто размер стека.
   * `ulimit -s 16384` - установить размер стека в 8 MB
 * `RLIMIT_CORE` - лимит на размер coredump'ов
   * `ulimit -c 0 `- запрещаем создавать core файлы
   * `ulimit -c unlimited` - разрешаем неограниченно создавать core файлы (*****)
 * `RLIMIT_RSS` - лимит на потребление оперативной памяти (реально подгруженной в RAM). Работает только в определенных 
     версиях linux. Так что не стоит закладываться на это.
 * `RLIMIT_NPROC` - лимит на количество процессов/потоков запущенных от текущего пользователя.
   * `ulimit -u 64` - запретить создавать больше 64 потоков/процессов.
 * `RLIMIT_NOFILE`- лимит на количество одновременно открытых файлов
   * `ulimit -n 5` - запретить открывать больше 5 файлов.
 * `RLIMIT_AS` - лимит на потребление виртуальной памяти.
   * `ulimit -v 100000` - ограничить размер используемой виртуальной памяти в 100 MB ...


Поскольку изменение размера стека - очень опасная операция, которая может нарушить структуру размещения данных в памяти, изменять этот лимит можно только до запуска функции `main`, либо непосредственно перед выполнением `exec`. В противном случае поведение программы не определено.

Примеры лимитов см. в [get_limits.c](https://github.com/victor-yacovlev/mipt-diht-caos/blob/master/practice/exec-rlimit-ptrace/get_limits.c).

Пример изменения размера стека см. в [shell_with_custom_stack_size.c](https://github.com/victor-yacovlev/mipt-diht-caos/blob/master/practice/exec-rlimit-ptrace/shell_with_custom_stack_size.c).
