# Семинар №7
## Вещественная арифметика в x86_64

Минималистичная презентация по мотивам семинара: [link](https://my.eng.utah.edu/~cs4400/sse-fp.pdf)

---
### Сопроцессор x87
_(На самом деле нет, сопроцессор для вещественных операций уже не используется, но инструкции остались с тех времен, 
когда использовался.)_  
  
__TL;DR__ Нет специальных вещественных регистров, есть только особый
стек из 8 "регистров". В стек можно класть и доставать. Записывать в памяти и из
памяти можно только с вершины стека st(0). Для работы имеются отдельные операции.  
_Дополнительный комментарий касаемо соглашения о вызовах в 32битной архитектуре_:
вещественные аргументы передаются через стек, возвращаемое вещественное значение на 
верхушке стека сопроцессора.
  
Операции над вещественными числами выполняются отдельными
блоками процессора. Исторически сложилось, что для
вещественной арифметики использовался отдельный
*сопроцессор*, а начиная с процессоров 486 (1991 год) этот
сопроцессор был интегрирован в кристалл основного
процессора.

Таким образом, в целях совместимости со старым кодом,
выполнение вещественных операций над числами с плавающей
точкой выполняется из предположения наличия сопроцессора.

Компилятор `gcc` использует по умолчанию именно этот способ
работы с вещественными числами для 32-разрядной архитектуры
(эквивалентно опции `-mfpmath=387`). Для 64-разрядной
архитектуры по умолчанию
используется набор команд SSE (`-mfpmath=sse`).

Взаимодействие с сопроцессором x87 организовано в
форме записи операндов в стек и выполнения операций
над элементами этого стека. Команды сопроцессора обычно
начинаются с буквы `f`, и оперируют с регистрами,
которые обозначаются от `st(0)` (вершина стека) до
`st(7)` (последний регистр FPU).

Выполнять арифметические FPU-операции можно над любыми
регистрами этого стека, но операции, позволяющие
взаимодействие c памятью, возможны только через
вершину стека `st(0)`.

Основные инструкции x86:
```
fld SIZE ptr ADDR // загрузить в стек значение из памяти
fld REG           // поместить на вершину стека значение из другого регистра st(X)
fld1              // поместить на вершину стека значение 1
fldz              // 0
fldpi             // π
fst SIZE ptr ADDR // сохранить из стека в память

fild SIZE ptr ADDR // загрузить целое число в стек
fist SIZE ptr ADDR // сохранить целое число из стека

fcom              // сравнение st(0) с памятью
fcomi             // сравнение st(0) с st(i)

fadd
fsub
fmul
fdiv              // операции над вещественными операндами

fiadd
fisub
fimul
fidiv             // операции над целочисленными операндами
```

---
### Регистры MMX/SSE/AVX/AVX-512

Reference по наборам команд MMX, SSE и AVX [на сайте Intel](https://software.intel.com/sites/landingpage/IntrinsicsGuide/).  

В современных Intel/AMD процессорах есть 16 регистров
(в 32-разрядном режиме доступны только 8),
которые предназначены как для вещественных операций, так
и для целочисленных.

128-битные регистры MMX/SSE именуются `xmm0`...`xmm7`,`xmm8`...`xmm15`.

256-битные регистры AVX `ymm0`...`ymm15` подразумевают, что
их младшие 128 бит совпадают с регистрами MMX/SSE.

512-битные регистры AVX-512 (новые Xeon и Core i9)
`zmm0`...`zmm15` подразумевают, что младшие 256 бит
совпадают с регистрами AVX.
  
__Немного истории__  
MMX (1997) (Multimedia Extensions — мультимедийные расширения)

64-битные регистры `mm0`..`mm7` (устарело)

SSE (1999) (Streaming SIMD Extensions)

128-битные регистры `xmm0`..`xmm7` (связи с регистрами MMX нет вроде бы) (количество может быть 16 и 32 на новых процессорах)

AVX (2008) (Advanced Vector Extensions)

256-битные регистры `ymm0` — `ymm15` (регистры SSE становятся младшими половинками регистров AVX) (количество может быть 32 на новых процессорах)

AVX-512 (2013) (Advanced Vector Extensions 512 bits)

512-битные регистры `zmm0`-`zmm31` (регистры AVX становятся младшими половинками регистров AVX-512)

Регистры поддерживают множество различных операций, по разному интерпретирующих содержимое регистров: регистр SSE может быть парой double, 4 float'ами, 8 short'ами и т. д. Над ними можно производить разные операции

### Скалярные инструкции SSE

Несмотря на свой большой размер, регистры SSE можно
использовать как обычные скалярные, что намного эффективнее,
чем x87 FPU.

В отличии от регистров в стеке `st(0)`...`st(7)`, все
регистры SSE являются равнозначными.

```
// Копирование регистр-регистр и регистр-память
movsd   DST, SRC  // пересылка double
movss   DST, SRC  // пересылка float

// Арифметические
addsd   DST, SRC   // DST += SRC, double
addss   DST, SRC   // DST += SRC, float
subsd   DST, SRC   // DST -= SRC, double
subss   DST, SRC   // DST -= SRC, float
mulsd   DST, SRC   // DST *= SRC, double
mulss   DST, SRC   // DST *= SRC, float
divsd   DST, SRC   // DST /= SRC, double
divss   DST, SRC   // DST /= SRC, float
sqrtsd  DST, SRC   // DST = sqrt(SRC), double
sqrtss  DST, SRC   // DST = sqrt(SRC), float
maxsd   DST, SRC   // DST = max(DST, SRC), double
maxss   DST, SRC   // DST = max(DST, SRC), float
minsd   DST, SRC   // DST = min(DST, SRC), double
minss   DST, SRC   // DST = min(DST, SRC), float

// Преобразования
cvtsd2si DST, SRC  // double -> int
cvtsi2sd DST, SRC  // int -> double

// Сравнения (операция DST-SRC, которая меняет флаги)
comisd  DST, SRC  // для double
comiss  DST, SRC  // для float

```

### Векторные инструкции SSE и intrisics-функции на Си

Между регистрами можно выполнять *векторные* операции, то
есть операции сразу над несколькими 8, 16, 32 или 64-битными
значениями, которые хранятся в паре 128-битных регистров.

Общий вид таких команд следующий:
```
OPERATION p [s|d]
```
где `OPERATION` - это одна из операций `add`, `mul` и т.д.,
буква `p` в названии команды является сокращением от
`p`acked, а `s` или `d` - это `s`ingle или `d`ouble точность
вещественных чисел.

Загрузка/сохранение выполняется вариантами команды `mov`:
```
mov[ap|up][s|d]   DST, SRC
```
где `ap` - загрузка/сохнанение из памяти, выровненной по
границе размера регистра (16 байт), `up` - для
невыровненной памяти.

Использование операндов в памяти для операций, отличных от
`mov`, возможно только для выровненной памяти.

Для задействования векторных инструкций не обязательно
использовать язык ассемблера. Компиляторы Intel и `gcc`
имеют поддержку псевдо-функций, объявленных в заголовочных
файлах вида `*intrin.h`, которые транслируются в эти
инструкции при компиляции. Подробный Reference
[доступен здесь](https://software.intel.com/sites/landingpage/IntrinsicsGuide/).

### Полезные интринсики для работы с float'ами

* `_mm_dp_pd `
* `_mm_dp_ps `
* `_mm_add_epi8`
* `_mm_loadu_ps`
* `_mm_setzero_ps`
* `_mm_mul_ss`
* `_mm_add_ps`
* `_mm_hadd_ps`
* `_mm_cvtss_f32`

`aligned_alloc` - аллокация выровненной памяти [link](https://en.cppreference.com/w/c/memory/aligned_alloc)
