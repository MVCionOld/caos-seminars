# Семинар №8
## Системные вызовы

---

Системные вызовы для 32-х битной и 64-х битной архитектур отличаются.  
1. Номер системных вызовов отличаются:
   * для 32 bit: [link](https://gist.github.com/yamnikov-oleg/454f48c3c45b735631f2#32-bit-system-call-numbers-and-entry-vectors)
   * для 64 bit: [link](https://gist.github.com/yamnikov-oleg/454f48c3c45b735631f2#64-bit-system-call-numbers-and-entry-vectors)
2. Ассемблерная инструкция для системного вызова:
   * для 32 bit: `int    0x80` -- вызов программного прерывания процессора с номером прерывания `0x80` -- 
     стандартный номер прерывания для инициирования системных вызовов в Linux; в регистр `eax` передается номер 
     системного вызова (см. `/usr/include/asm/unistd_32.h`), параметры в `ebx`, `ecx`, `edx`, `esi`, `edi`, `ebp`, а 
     возвращаемое -- `eax`.
   * для 64 bit: предусмотрена специальная инструкция `syscall`, где номер системного вызова передается через `rax`, 
     а аргументы передаются через регистры: `rdi`, `rsi`, `rdx`, `r10`, `r8` и `r9`. Обратите внимание, что не все 
     используемые регистры совпадают со стандартным соглашением о вызовах в x86-64, например, вместо регистра `rcx`
     используется регистр `r10`. Кроме того, использование команды `syscall` может испортить содержимое регистров `rcx` и `r11`.

Примеры:
в x86 вызовет `exit`
```asm
mov eax, 0x1
int 0x80
```
в x86_64 вызовет `write`
```asm
mov rax, 0x1
syscall
```
В 64-битных системах возможно использовать соглашения о системных вызовах для 32-битных платформ x86, но этот механизм 
используется исключительно для обеспечения работоспособности старых 32-битных программ. При использовании инструкции 
`int 0x80` аргументы, передаваемые через регистры, усекаются до 32-битных значений, что может приводить к неопределенному 
поведению, например, если передаются указатели.

Информацию о системных вызовах можно посмотреть во 2ом разделе man.  
В стандартной библиотеке Си имеются именованные оболочки со стандартным Си-соглашением о вызовах функций.